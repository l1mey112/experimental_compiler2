; add: i32 -> i32 -> i32
; add: a b = a + b
; add: a 0 = a
; add: 0 b = b
; add: 0 0 = 0
; 
; addsome: i32 -> i32
; addsome: 'xs = xs += 20
; 
; addr: i32 -> i32
; addr: x = (&x).*
; 
; select: bool -> i32 -> i32 -> i32
; select: cond a b = if (cond) a else b
; 
; selectn: bool -> i32 -> ()
; selectn: cond a = if (cond) a
; 
; eeepy: i32 -> (i32, i32)
; eeepy: x = (x, undefined)
; 
; main: () -> ()
; main: () = :t do
;     brk :t 50 + 50
; 
; condbrk0: bool -> i32
; condbrk0: cond = :t do
;     brk :t if (cond) 50 + 50 else 25
; 
; c: bool -> i32
; c: cond = if (cond) 50 + 50 else 25
; 
; idx_ret: i32 -> i32
; idx_ret: x = [1, 2, 3, 4, if (x) 20 else 25][x]
; 
; slice_some: i32 -> i32 -> []i32 -> []i32
; slice_some: lo hi xs = do
;     let a = xs[lo..]
;     let b = xs[..hi]
;     let c = xs[lo..hi]
;     let d = xs[..]
; 
;     ()
; 
; idx_ret0: i32 -> i32
; idx_ret0: x = [1, if (x) 2 else 2, 3][x]
;

call: i32 -> i32 -> i32      ; (assume these types work)
call: 'f 'x = do
    let l
    l = (if (c) f else 1) x x x x

; (now fixed with proper spilling)
;
; ssa_bug: i32 -> i32
; ssa_bug: 'x = x + (x += 1)