; add: i32 -> i32 -> i32
; add: a b = a + b
; add: a 0 = a
; add: 0 b = b
; add: 0 0 = 0
; 
; addsome: i32 -> i32
; addsome: 'xs = xs += 20
; 
; addr: i32 -> i32
; addr: x = (&x).*
; 
; select: bool -> i32 -> i32 -> i32
; select: cond a b = if (cond) a else b
; 
; selectn: bool -> i32 -> ()
; selectn: cond a = if (cond) a
; 
; eeepy: i32 -> (i32, i32)
; eeepy: x = (x, x)
; 
; main: () -> ()
; main: () = :t do
;     brk :t 50 + 50
; 
; condbrk0: bool -> i32
; condbrk0: cond = :t do
;     brk :t if (cond) 50 + 50 else 25
; 
; c: bool -> i32
; c: cond = if (cond) 50 + 50 else 25
; 
; idx_ret: i32 -> i32
; idx_ret: x = [1, 2, 3, 4, if (x) 20 else 25][x]
; 
; slice_some: i32 -> i32 -> []i32 -> []i32
; slice_some: lo hi xs = do
;     let a = xs[lo..]
;     let b = xs[..hi]
;     let c = xs[lo..hi]
;     let d = xs[..]
; 
;     ()
; 
; idx_ret0: i32 -> i32
; idx_ret0: x = [1, if (x) 2 else 2, 3][x]
; 
; call: i32 -> i32 -> i32
; call: 'f 'x = do
;     let l
;     l = (if (c) f else 1) x x x x
; 
; ssa_bug: i32 -> i32
; ssa_bug: 'x = x + (x += 1)
; 
; repeat: () -> ()
; repeat: () = :t do
;     rep :t
; 
; fact: i32 -> i32
; fact: n = if (n == 0) 1 else n * fact (n - 1)
; 
; fact_iter: i32 -> i32
; fact_iter: 'i = do
;     let 'f = 1
;     loop do
;         if (i < 1) brk f
;         f = f * i
;         i--
; 
; test: () -> ()
; test: () = loop ret ()
; 
; fact_full: i32 -> i32
; fact_full: n = do
;     if (n == 0) do
;         ret 1
;     else do
;         ret n * fact_full (n - 1)
; 
; inc_double: (i32, i32) -> (i32, i32)
; inc_double: (x, y) = (inc x, inc y)
; 
; ident: i32 -> i32
; ident: x = x
; 
; inc: i32 -> i32
; inc: x = ident x + 1
; 
; fear: u8 -> u8
; fear: a = loop brk a
; 
; fer: u8 -> u8
; fer: a = :t do
;     a
;     a
; 
; arre: i32 -> []i32
; arre: t = :t do
;     let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
;     [1, 2, 3]
; 
; dec_loop: i32 -> i32
; dec_loop: 'x = loop do
;     x--
;     brk x
; 
; far: () -> i32
; far: () = :t do
;     brk :t 20
;     40
; 
; aar: i32 -> i32 -> i32
; aar: f x = :k do
;     let g = 20
;     g
; 
; inc_double((x: i32, y: i32)) -> (i32, i32)
; 
; test1 = test0
; test0 = test1
; 
; ; test = teeeeeeeeees
; ; test0 = test1
; ; test1 = test0
; ; obvious_cycle = 50 + obvious_cycle
; ; intrusive: *i32 = &intrusive
; 
; inc_double(t: (i32, i32)) -> (i32, i32) = (inc t.0, inc t.1)
; 
; ident(x: i32) -> i32 = x
; 
; inc(x: i32) -> i32 = ident x + 1
; 
; F() = 0
; 
; struct Foo {
;     x: i32
;     y: F
; }
; 
; take(a: Foo) = 0
; 
; struct Test0 {
;     a: Test1
; }
; 
; struct Test1 {
;     a: Test0
; }
; 
; test1 = test0
; test0 = test1
; 
; ; use func(): T instead of func() -> T ????
; 
; struct T {
;     b: Eeer
; }
; 
; func() -> NotReal = 0
; 
; func() = do
;     let t: NotReal =  20: Fard
; 
; not_existing: NonExisting = 0
; 
; F() = 0
; 
; struct Foo {
;     x: i32
;     y: F
; }
; 
; global: funcer = 0
; 
; funcer() -> global = 0
; 
; struct T {}
; 
; glob = T
; 
; selfrec = &selfrec[selfrec]
; selfrec = &selfrec[&selfrec]
; 
; struct Foo {
;     x: i32
;     y: *Foo
; }
; 
; selfcall() -> () = selfcall
; 
; fact(t: i32) -> i32 =
;     if (t == 0) 1 else t * fact (t - 1)
; 
; mutrec0() = mutrec1
; mutrec1() -> () = mutrec2
; mutrec2() = mutrec0
; 
; struct Test0 {
;     a: Test1
; }
; 
; struct Test1 {
;     a: Test2
; }
; 
; struct Test2 {
;     a: *Test0
; }
; 
; test = &test
; 
; global = void :t do
;     29
;     29
;     29
;     29
; 
; factacc(n: i32) = factacc0 n 1
; 
; factacc0(n: i32, acc: i32): i32 =
;     if (n <= 1) acc else factacc0 (n - 1) (n * acc)
; 
; maine(v': i32) = void do
;     v++
;     v++
;     v++
;     v++
;     v++
;     v++
; 
; unpackadd(a: (i32, i32)) = a.0 + a.1
; 
; struct Foo {
;     x: i32
;     y: i32
; }
; 
; unpackfoo(a: Foo) = a.x + a.y
; 
; main() = do
;     let (a', b) = (1, 2)
;     a = 40
;     a
; 
; f() = 20 + ret 5 + ret 255
; 
; f(v': i32) = (v = 50) + ret v
; 
; f(c: bool) = if (c) 250 else 12

; factacc(n: i32) = factacc0 n 1
; 
; factacc0(n: i32, acc: i32): i32 =
;     if (n <= 1) acc else factacc0 (n - 1) (n * acc)

; main() = do
;     50
;     60
;     23

; factacc(n: i32) = factacc0 n 1
; 
; factacc0(n: i32, acc: i32): i32 =
;     if (n <= 1) acc else factacc0 (n - 1) (n * acc)

; not_allowed() = 20:!

; fact_iter(i': i32) = do
;     let f' = 1
;     loop do
;         if (i < 1) brk f
;         f = f * i
;         i--

; fact_full(n: i32): i32 = do
;     if (n == 0) ret 1
;     else ret n * fact_full (n - 1)
; 
; unitmaker(c: bool) = if (c) () else ()

; repeat() = :t do
;     rep :t

; struct T {
;     count: i32
; }
; 
; new(): T = T{}
; 
; incv_lit(v: T): T = T{}
; 
; incv_field(v': T): T = do
;     v.count++
;     v

; cond(c: bool) = :t do
;     if (c) brk :t 20
; 
;     if (!c) 40 else 2

; dostuffs() = do
;     let a = :t do
;         brk :t 50
;     8

; expr_forwarding(c: bool) = do
;     let a = if (c) (if (c) 120 else 23) else 59
;     a

; fact_iter_forwarding(i': i32) = do
;     let f' = 1
;     let take = loop do
;         if (i < 1) brk f
;         f = f * i
;         i--
;     take

; do_forwarding(c: bool) = do
;     let take = :t do
;         if (c) brk :t 20
;         240
;     take
; 
; do_forwarding_discard(c: bool) = do
;     let _ = :t do
;         if (c) brk :t 20
;         240
;     50
; 
; if_forwarding_discard(c: bool) = do
;     let t = if (c) () else ()
;     50

; local = hir.local_new desc hir.local_t{
;     name: none
;     kind: .imm
;     type: loop_type
;     loc: none
; }

; loop_forwarding_i32(c': i32) = do
;     loop do
;         if (c <= 0) brk c
;         c--

; ret_forwarding(c: bool) = do
;     ret :t do
;         if (c) brk :t 230
;         40

; access(k: usize, xs: []i32): i32 = xs[k]

; from(i': i32) = do
;     i += 3 + 50

; from_lvalue(i: []i32): () = do
;     let k': usize = 0
;     let g'                ; `let g; g = ...` doesn't work as it's a current limitation
; 
;     i[g = k++] = 0

; unit() = ()
; 
; takers(a: (), b: i32, c: ()) = b
; 
; users() = do
;     takers unit 40 unit

; loopin() = loop ()
; 
; along_us() = do
;     let a = loopin
;     a

; from_lvalue(i: []i32): () = do
;     let k': usize = 0
;     let g'
; 
;     i[g = k++] = 0

; struct Foo {
;     x: i32
;     y: i32
; }
; 
; make_foo() = Foo{x: 20}

; Foo{x: 20}
; Foo{20, 50}

; type Alias = i32
; 
; ret_alias(): Alias = 20:Alias

; type Sum = u32 | i32

struct Foo {
    x: i32
}

Foo.incr(a: Foo, b: i32, c: i32) = b
Foo.voider(a: Foo) = ()
Foo.static(a: i32) = a

main() = do
    let a = Foo{x: 20}
    
    a.incr 20 50
    Foo.incr a 20 50
    
    a.voider
    Foo.voider a

    Foo.static 20