; add: i32 -> i32 -> i32
; add: a b = a + b
; add: a 0 = a
; add: 0 b = b
; add: 0 0 = 0
; 
; addsome: i32 -> i32
; addsome: 'xs = xs += 20
; 
; addr: i32 -> i32
; addr: x = (&x).*
; 
; select: bool -> i32 -> i32 -> i32
; select: cond a b = if (cond) a else b
; 
; selectn: bool -> i32 -> ()
; selectn: cond a = if (cond) a
; 
; eeepy: i32 -> (i32, i32)
; eeepy: x = (x, x)
; 
; main: () -> ()
; main: () = :t do
;     brk :t 50 + 50
; 
; condbrk0: bool -> i32
; condbrk0: cond = :t do
;     brk :t if (cond) 50 + 50 else 25
; 
; c: bool -> i32
; c: cond = if (cond) 50 + 50 else 25
; 
; idx_ret: i32 -> i32
; idx_ret: x = [1, 2, 3, 4, if (x) 20 else 25][x]
; 
; slice_some: i32 -> i32 -> []i32 -> []i32
; slice_some: lo hi xs = do
;     let a = xs[lo..]
;     let b = xs[..hi]
;     let c = xs[lo..hi]
;     let d = xs[..]
; 
;     ()
; 
; idx_ret0: i32 -> i32
; idx_ret0: x = [1, if (x) 2 else 2, 3][x]
; 
; call: i32 -> i32 -> i32
; call: 'f 'x = do
;     let l
;     l = (if (c) f else 1) x x x x
; 
; ssa_bug: i32 -> i32
; ssa_bug: 'x = x + (x += 1)
; 
; repeat: () -> ()
; repeat: () = :t do
;     rep :t
; 
; fact: i32 -> i32
; fact: n = if (n == 0) 1 else n * fact (n - 1)
; 
; fact_iter: i32 -> i32
; fact_iter: 'i = do
;     let 'f = 1
;     loop do
;         if (i < 1) brk f
;         f = f * i
;         i--
; 
; test: () -> ()
; test: () = loop ret ()
; 
; fact_full: i32 -> i32
; fact_full: n = do
;     if (n == 0) do
;         ret 1
;     else do
;         ret n * fact_full (n - 1)
; 
; inc_double: (i32, i32) -> (i32, i32)
; inc_double: (x, y) = (inc x, inc y)
; 
; ident: i32 -> i32
; ident: x = x
; 
; inc: i32 -> i32
; inc: x = ident x + 1
; 
; fear: u8 -> u8
; fear: a = loop brk a
; 
; fer: u8 -> u8
; fer: a = :t do
;     a
;     a
; 
; arre: i32 -> []i32
; arre: t = :t do
;     let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
;     [1, 2, 3]
; 
; dec_loop: i32 -> i32
; dec_loop: 'x = loop do
;     x--
;     brk x
; 
; far: () -> i32
; far: () = :t do
;     brk :t 20
;     40
; 
; aar: i32 -> i32 -> i32
; aar: f x = :k do
;     let g = 20
;     g
; 
; inc_double((x: i32, y: i32)) -> (i32, i32)
; 
; test1 = test0
; test0 = test1
; 
; ; test = teeeeeeeeees
; ; test0 = test1
; ; test1 = test0
; ; obvious_cycle = 50 + obvious_cycle
; ; intrusive: *i32 = &intrusive
; 
; inc_double(t: (i32, i32)) -> (i32, i32) = (inc t.0, inc t.1)
; 
; ident(x: i32) -> i32 = x
; 
; inc(x: i32) -> i32 = ident x + 1
; 
; F() = 0
; 
; struct Foo {
;     x: i32
;     y: F
; }
; 
; take(a: Foo) = 0
; 
; struct Test0 {
;     a: Test1
; }
; 
; struct Test1 {
;     a: Test0
; }
; 
; test1 = test0
; test0 = test1
; 
; ; use func(): T instead of func() -> T ????
; 
; struct T {
;     b: Eeer
; }
; 
; func() -> NotReal = 0
; 
; func() = do
;     let t: NotReal =  20: Fard
; 
; not_existing: NonExisting = 0
; 
; F() = 0
; 
; struct Foo {
;     x: i32
;     y: F
; }
; 
; global: funcer = 0
; 
; funcer() -> global = 0
; 
; struct T {}
; 
; glob = T
; 
; selfrec = &selfrec[selfrec]
; selfrec = &selfrec[&selfrec]
; 
; struct Foo {
;     x: i32
;     y: *Foo
; }
; 
; selfcall() -> () = selfcall
; 
; fact(t: i32) -> i32 =
;     if (t == 0) 1 else t * fact (t - 1)
; 
; mutrec0() = mutrec1
; mutrec1() -> () = mutrec2
; mutrec2() = mutrec0
; 
; struct Test0 {
;     a: Test1
; }
; 
; struct Test1 {
;     a: Test2
; }
; 
; struct Test2 {
;     a: *Test0
; }
; 
; test = &test
; 
; global = void :t do
;     29
;     29
;     29
;     29
; 
; factacc(n: i32) = factacc0 n 1
; 
; factacc0(n: i32, acc: i32): i32 =
;     if (n <= 1) acc else factacc0 (n - 1) (n * acc)
; 
; maine(v': i32) = void do
;     v++
;     v++
;     v++
;     v++
;     v++
;     v++
; 
; unpackadd(a: (i32, i32)) = a.0 + a.1
; 
; struct Foo {
;     x: i32
;     y: i32
; }
; 
; unpackfoo(a: Foo) = a.x + a.y
; 
; main() = do
;     let (a', b) = (1, 2)
;     a = 40
;     a
; 
; f() = 20 + ret 5 + ret 255
; 
; f(v': i32) = (v = 50) + ret v
; 
; f(c: bool) = if (c) 250 else 12

; factacc(n: i32) = factacc0 n 1
; 
; factacc0(n: i32, acc: i32): i32 =
;     if (n <= 1) acc else factacc0 (n - 1) (n * acc)

; main() = do
;     50
;     60
;     23

; factacc(n: i32) = factacc0 n 1
; 
; factacc0(n: i32, acc: i32): i32 =
;     if (n <= 1) acc else factacc0 (n - 1) (n * acc)

fact_iter(i': i32) = do
    let f' = 1
    loop do
        if (i < 1) brk f
        f = f * i
        i--

fact_full(n: i32): i32 = do
    if (n == 0) ret 1
    else ret n * fact_full (n - 1)

unitmaker(c: bool) = if (c) () else ()